import { ethers, SigningKey } from "ethers";
import { EIP712_TX_TYPE, DEFAULT_GAS_PER_PUBDATA_LIMIT } from "./utils";
import { TransactionLike, TransactionBuilder, PayloadSigner } from "./types";

/**
 * Sings the `payload` using an ECDSA private key.
 */
export const signPayloadWithECDSA: PayloadSigner = async (payload, secret, _) => {
    return new ethers.Wallet(secret as string | SigningKey).signingKey.sign(payload).serialized;
};

/**
 * Sings the `payload` using multiple ECDSA private keys.
 * The signature is generated by concatenating signatures created by signing each key individually.
 * The length of the resulting signature should be `secrets.length * 65`.
 *
 * @throws  An error if secret is not an array of at least two elements.
 */
export const signPayloadWithMultipleECDSA: PayloadSigner = async (payload, secret, _) => {
    if (!Array.isArray(secret) || secret.length < 2) {
        throw new Error("Multiple keys are required for multisig transaction signing!");
    }

    const signatures = secret.map(
        (key: string | SigningKey) =>
            // Note, that `signMessage` wouldn't work here, since we don't want
            // the signed hash to be prefixed with `\x19Ethereum Signed Message:\n`
            ethers.Signature.from(new ethers.Wallet(key).signingKey.sign(payload)).serialized,
    );

    return ethers.concat(signatures);
};

/**
 * Populates missing properties meant for signing using an ECDSA private key:
 *
 * - Populates `from` using the address derived from the ECDSA private key.
 * - Populates `nonce` via `provider.getTransactionCount(tx.from, "pending")`.
 * - Populates `gasLimit` via `provider.estimateGas(tx)`.
 * - Populates `chainId` via `provider.getNetwork()`.
 * - Populates `type` with `utils.EIP712_TX_TYPE`.
 * - Populates `value` by converting to `bigint` if set, otherwise to `0n`.
 * - Populates `data` with `0x`.
 * - Populates `customData` with `{factoryDeps=[], gasPerPubdata=utils.DEFAULT_GAS_PER_PUBDATA_LIMIT}`.
 *
 * @throws An error when `provider` is not set.
 */
export const populateTransaction: TransactionBuilder = async (tx, secret, provider) => {
    if (!provider) {
        throw new Error("Provider is required but is not provided!");
    }

    const populatedTx = { ...tx };

    populatedTx.type = EIP712_TX_TYPE;
    populatedTx.chainId ??= (await provider.getNetwork()).chainId;
    populatedTx.value = populatedTx.value != undefined ? BigInt(populatedTx.value) : 0n;
    populatedTx.data ??= "0x";
    populatedTx.gasPrice ??= await provider.getGasPrice();
    populatedTx.customData = tx.customData ?? {};
    populatedTx.customData.gasPerPubdata ??= DEFAULT_GAS_PER_PUBDATA_LIMIT;
    populatedTx.customData.factoryDeps ??= [];

    if (populatedTx.from) {
        const isContractAccount = ethers.getBytes(await provider.getCode(populatedTx.from)).length != 0;
        if (isContractAccount) {
            // Gas estimation does not work when initiator is contract account (works only with EOA).
            // In order to  estimation gas, the transaction's from value is replaced with signer's address.
            populatedTx.gasLimit ??= await provider.estimateGas({
                ...populatedTx,
                from: new ethers.Wallet(secret as string | SigningKey).address,
            });
        }
    }

    populatedTx.from ??= new ethers.Wallet(secret as string | SigningKey).address;
    populatedTx.gasLimit ??= await provider.estimateGas(populatedTx);
    populatedTx.nonce ??= await provider.getTransactionCount(populatedTx.from, "pending");
    return populatedTx as TransactionLike;
};

/**
 * Populates missing properties meant for signing using multiple ECDSA private keys.
 * It uses {@link populateTransaction}, where the address of the first ECDSA key is set as the `secret` argument.
 *
 * @throws An error if secret is not an array and requires at least two elements.
 */
export const populateTransactionMultisig: TransactionBuilder = async (tx, secret, provider) => {
    if (!Array.isArray(secret) || secret.length < 2) {
        throw new Error("Multiple keys are required to build the transaction!");
    }
    // populatesTransaction estimates gas which accepts only one address, so the first signer is choosen.
    return populateTransaction(tx, secret[0], provider);
};
