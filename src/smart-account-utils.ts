import { ethers, SigningKey } from "ethers";
import { EIP712Signer } from "./signer";
import { EIP712_TX_TYPE, DEFAULT_GAS_PER_PUBDATA_LIMIT, serializeEip712 } from "./utils";
import {
    TransactionLike,
    TransactionSigner,
    MessageSigner,
    TransactionBuilder,
    TypedDataSigner,
} from "./types";

/**
 * Implementation of {@link TransactionSigner} which uses an ECDSA private key
 * as a `secret` for singing the `tx`.
 */
export const signTransaction: TransactionSigner = async (tx, secret, provider) => {
    if (!provider) {
        throw new Error("Provider is required but is not provided!");
    }

    const signer = new EIP712Signer(
        new ethers.Wallet(secret as string | SigningKey, provider),
        Number((await provider.getNetwork()).chainId),
    );
    // exepects that the transaction has already been populated with valid values
    tx.customData = {
        ...tx.customData,
        customSignature: await signer.sign(tx),
    };
    return serializeEip712(tx);
};

/**
 * Implementation of {@link MessageSigner} which uses an ECDSA private key
 * as a `secret` for singing the `message`.
 */
export const signMessage: MessageSigner = async (message, secret, _) => {
    const signer = new ethers.Wallet(secret as string | SigningKey);
    return signer.signMessage(message);
};

/**
 * Implementation of {@link TransactionBuilder} which populates missing properties
 * meant for signing using an ECDSA private key:
 *
 * - Populates `from` using the address derived from the ECDSA private key.
 * - Populates `nonce` via `provider.getTransactionCount(tx.from, "pending")`.
 * - Populates `gasLimit` via `provider.estimateGas(tx)`.
 * - Populates `chainId` via `provider.getNetwork()`.
 * - Populates `type` with `utils.EIP712_TX_TYPE`.
 * - Populates `value` by converting to `bigint` if set, otherwise to `0n`.
 * - Populates `data` with `0x` if not set.
 * - Populates `customData` with `{factoryDeps=[], gasPerPubdata=utils.DEFAULT_GAS_PER_PUBDATA_LIMIT}` if not set.
 */
export const populateTransaction: TransactionBuilder = async (tx, secret, provider) => {
    if (!provider) {
        throw new Error("Provider is required but is not provided!");
    }

    const populatedTx = { ...tx };

    populatedTx.type = EIP712_TX_TYPE;
    populatedTx.chainId ??= (await provider.getNetwork()).chainId;
    populatedTx.value = populatedTx.value != undefined ? BigInt(populatedTx.value) : 0n;
    populatedTx.data ??= "0x";
    populatedTx.gasPrice ??= await provider.getGasPrice();
    populatedTx.customData = tx.customData ?? {};
    populatedTx.customData.gasPerPubdata ??= DEFAULT_GAS_PER_PUBDATA_LIMIT;
    populatedTx.customData.factoryDeps ??= [];

    if (populatedTx.from) {
        const isContractAccount = ethers.getBytes(await provider.getCode(populatedTx.from)).length != 0;
        if (isContractAccount) {
            // Gas estimation does not work when initiator is contract account (works only with EOA).
            // In order to  estimation gas, the transaction's from value is replaced with signer's address.
            populatedTx.gasLimit ??= await provider.estimateGas({
                ...populatedTx,
                from: new ethers.Wallet(secret as string | SigningKey).address,
            });
        }
    }

    populatedTx.from ??= new ethers.Wallet(secret as string | SigningKey).address;
    populatedTx.gasLimit ??= await provider.estimateGas(populatedTx);
    populatedTx.nonce ??= await provider.getTransactionCount(populatedTx.from, "pending");
    return populatedTx as TransactionLike;
};

/**
 * Implementation of {@link TypedDataSigner} which uses an ECDSA private key
 * as a `secret` for singing the typed data.
 */
export const signTypedData: TypedDataSigner = async (domain, types, value, secret, _) => {
    const signer = new ethers.Wallet(secret as string | SigningKey);
    return signer.signTypedData(domain, types, value);
};

/**
 * Implementation of {@link TransactionSigner} which uses multiple ECDSA private keys
 * as a `secret` for singing the `tx`.
 * The signature is generated by concatenating signatures created by signing each key individually.
 * The length of the resulting signature should be `secrets.length * 65`.
 */
export const signTransactionMultisig: TransactionSigner = async (tx, secret, _) => {
    if (!Array.isArray(secret) || secret.length < 2) {
        throw new Error("Multiple keys are required for multisig transaction signing!");
    }

    const signedTxHash = EIP712Signer.getSignedDigest(tx);

    const signatures = secret.map(
        (key: string | SigningKey) =>
            // Note, that `signMessage` wouldn't work here, since we don't want
            // the signed hash to be prefixed with `\x19Ethereum Signed Message:\n`
            ethers.Signature.from(new ethers.Wallet(key).signingKey.sign(signedTxHash)).serialized,
    );

    const signature = ethers.concat(signatures);

    tx.customData = {
        ...tx.customData,
        customSignature: signature,
    };
    return serializeEip712(tx);
};

/**
 * Implementation of {@link MessageSigner} which uses multiple ECDSA private keys
 * as a `secret` for singing the `message`.
 * The signature is generated by concatenating signatures created by signing each key individually.
 * The length of the resulting signature should be `secrets.length * 65`.
 */
export const signMessageMultisig: MessageSigner = async (message, secret, _) => {
    if (!Array.isArray(secret) || secret.length < 2) {
        throw new Error("Multiple keys are required for multisig message signing!");
    }

    const signatures = await Promise.all(
        secret.map((key: string | SigningKey) => new ethers.Wallet(key).signMessage(message)),
    );

    return ethers.concat(signatures);
};

/**
 * Implementation of {@link TransactionBuilder} which populates missing properties
 * meant for signing using multiple ECDSA private keys. It uses {@link populateTransaction},
 * where the address of the first ECDSA key is set as the `secret` argument.
 */
export const populateTransactionMultisig: TransactionBuilder = async (tx, secret, provider) => {
    if (!Array.isArray(secret) || secret.length < 2) {
        throw new Error("Multiple keys are required to build the transaction!");
    }
    // populatesTransaction estimates gas which accepts only one address, so the first signer is choosen.
    return populateTransaction(tx, secret[0], provider);
};

/**
 * Implementation of {@link TypedDataSigner} which uses mutliple ECDSA private keys
 * as `secret` for singing typed data.
 * The signature is generated by concatenating signatures created by signing each key individually.
 * The length of the resulting signature should be `secrets.length * 65`.
 */
export const signTypedDataMultisig: TypedDataSigner = async (domain, types, value, secret, _) => {
    if (!Array.isArray(secret) || secret.length < 2) {
        throw new Error("Multiple keys are required for multisig typed data signing!");
    }

    const signatures = await Promise.all(
        secret.map((key: string) => new ethers.Wallet(key).signTypedData(domain, types, value)),
    );

    return ethers.concat(signatures);
};
